/* Provide hints for Tamarin's heuristics.  In this case, we tell
   Tamarin to delay (make "Last", "L_") finding the sources for the
   Sigs_Check_List fact, since it doesn't provide useful information and can
   lead to non-termination.  */

/* In this proof, we use several abstractions. For example, we treat
   our log structure as a list to record simplified data item. */


theory BKI_protocol_security

/* Author: Zhiguo Wan*/

/*
    =======Entity=======


    - Certificate authorities (CA) check the identity of domain
      owners, and create certificates for the domain owners'
      keys. However, in contrast with today's CAs, the ability of CAs
      in DTKI is limited since the issuance of a certificate from a CA
      is not enough to convince web browsers to accept the certificate
      (proof of presence in the relevant CLM is also needed).


    =======Adversary model=======

    We consider an adversary who can compromise the private key of all
    infrastructure servers in DTKI. In other words, the adversary can
    collude with all log servers and certificate authorities to launch
    attacks. In addition, we assume that each domain server can
    securely setup a master key with the corresponding CLM, and will
    be able to keep the master key private.

    =======Protocol=======


    =======Notes=======

    Rule name: All capital, with '_' to separate words, e.g. RULE_NAME

    Actions: First letter is capital, with '_' to separate words,
    e.g. Action_Name

    State facts: Eg, 'StSecureCommA1' start with 'St', ends in role name
    and step in role that outputs it. By convention, the first argument
    is the thread identifier (tid), freshly generated in the first step
    of the role.

    Conclusion: First letter is capital, without '_',
    e.g. ConclusionName

    Lemma and restriction: lower case letter only, with '_' to separate
    words, e.g.lemma_name

*/

//theory BKI
begin

builtins: multiset

functions: adec/2, aenc/2, fst/1, h/1, pair/2, pk/1, sdec/2, senc/2,
  sign/2, snd/1, false/0, true/0, verify/3
equations:
    adec(aenc(x.1, pk(x.2)), x.2) = x.1,
    fst(<x.1, x.2>) = x.1,
    sdec(senc(x.1, x.2), x.2) = x.1,
    snd(<x.1, x.2>) = x.2,
    verify(sign(x.1, x.2), x.1, pk(x.2)) = true


restriction Unique: "All x #i #j. Uniq(x) @ i & Uniq(x) @ j ==> #i = #j"
restriction InEq:   "not (Ex x #i. InEq(x,x) @ i)"
restriction types_distinct:
  "(All t1 t2 x #i #j. (Is_Type(t1,x)@i & Is_Type(t2,x)@j) ==> (t1 = t2))"

restriction eq_check_succeed:
  "All x y #i. Eq(x,y) @ i ==> x = y"

restriction neq_check_succeed:
  "All x y #i. Neq(x,y) @ i ==> not (x = y)"

restriction notin_check_succeed:
  "All x l #i. NotIn(x,l) @ i ==> not (Ex rest. x+rest = l)"

restriction in_check_succeed:
  "All x l #i. IsIn(x,l) @ i ==> Ex rest. x+rest = l"

restriction subseteq_check_succeed:
  "All l m #i. SubsetEq(l,m) @ i ==> ( ( l = m ) | (Ex rest. l+rest = m) )"



/* Secure channel between Domain and CAs */
rule ChanOut_S:
        [ Out_S($A,$B,x) ]
      --[ ChanOut_S($A,$B,x) ]->
        [ !Sec($A,$B,x) ]

rule ChanIn_S:
        [ !Sec($A,$B,x) ]
      --[ ChanIn_S($A,$B,x) ]->
        [ In_S($A,$B,x) ]


/* Initialize the whole system */
rule INIT_SYSTEM_PARAMS:
   let 
//        n = '1'+'1'+'1'+'1'+'1'			// 3 CAs in total
//        k = '1'+'1'+'1'			// 2 out of 3 CAs required to issue a cert.
//        t = '1'
	Init = <'INITSYS', n, k, t>	//
   in
    [ In(Init) ]
    --[ SubsetEq(k, n),
        SubsetEq(t, k),
        InEq(n, 'nil'),
        InEq(k, 'nil'),
	Uniq('INITSYS')]->
    [!PubParams(n, k, t),
     Compromised_CAs('nil'),
      Out(<n, k>)]

/*Initialisation: Certificate log maintainer CLM1. */

rule INIT_BLM:
    [ Fr(~ltkB)
      ]		// Assume rgxC is fresh and associated with C. --Zhiguo
  --[ Is_Type('BLM', $B),
      Only_One('INITBLM') // 
    ]->
    [ !Ltk($B, ~ltkB),
      !Pk($B, pk(~ltkB)),
      StStateInitBLM($B, pk(~ltkB)),
      Out(pk(~ltkB))
    ]



/*Initialisation: Certificate log. */

rule INIT_BLOG:
     [
      !Ltk($B, ltkB),
      StStateInitBLM($B, pk(ltkB)),
      Fr(~blogid)
     ]
   --[ Is_Type('BLM', $B),
       Only_One('BLOG') // Each log maintainer has only one log.
     ]->
     [
      //!CLM_RGX($C, pk(ltkC), rgxC),		// Persistent fact that C is associated with rgxC, 
						// Do not consume StStateInitCLM. --Zhiguo
      L_Blog($B, ~blogid, 'nil') // the log maintained by the
                                          // CLM is for domains whose
                                          // name is an instence of
                                          // regular expression RGX1
     ]


  /* Initialisation: Certificate authorities*/

  rule INIT_CA:
  let q = < 'Init_CA', CAid, $CA>
  in
  [  In(q),
     Fr(~ltkCA),
     !PubParams(n, k, t)]
  --[
     Is_Type('CA', $CA),
     Uniq(<'CA', $CA>),		// Multiple CAs needed, each one is init only once
     Uniq(<'CA', CAid>),		// Multiple CAs needed, each one is init only once
     IsIn(CAid, n+'1')		// $CA is in form of '1'+...+'1'
     ]->

  [ !Ltk($CA, ~ltkCA),
    !Pk($CA, pk(~ltkCA)),	// bind CA with its public key ltkCA. Zhiguo
    !Pmap( CAid, $CA ),
    Out(pk(~ltkCA))
  ]


  /* Compromise a CA */

  rule COMPROMISE_CA:
   [ !Ltk($CA, ltkCA),
     Compromised_CAs(Compromised_CA_List)
    ]
  --[
     Is_Type('CA', $CA),
     Uniq(<'Compromise_CA', $CA>),
     Compromise_CA($CA,ltkCA)
     ]->

  [
   Compromised_CAs(Compromised_CA_List+'1'),
   Out(ltkCA)
  ]
  
  rule COMPROMISE_k_CAs:
    [
   !PubParams(n,k,t),
   Compromised_CAs(Compromised_CA_List)
    ]
   --[
   Eq(k+'nil', Compromised_CA_List),
   K_CAs_Compromised(Compromised_CA_List)
    ]->[
    ]
  

  /* Compromise a BLM */

  rule COMPROMISE_BLM:
          [ !Ltk($B, ltkB)
          ]
  --[
     Is_Type('BLM', $B),
     Compromise_BLM($B,ltkB)
     ]->

  [
   Out(ltkB),
   StCompromisedBLM($B,ltkB)
  ]

/*Initialisation: domain server Did*/

rule INIT_DOMAIN:
     [ Fr(~ltkD),
       Fr(~Did)
     ]
  --[ Is_Type('Domain', $D), 
      Uniq( < 'Init_Domain', $D > ) ]->	// A domain initialze once --Zhiguo
  [ !Ltk($D, ~ltkD),
    !Pk($D, pk(~ltkD)),
    !DomainInfo($D, ~Did, pk(~ltkD)),
    Sigs_List($D, ~Did, 'nil', 'nil', 'nil'),	// The first list is sigs_list, the second is list of CA public keys, third is the counter
    L_Sigs_Check_List($D, ~Did, 'nil'),		// To store sigs that have been verified. Zhiguo
    Out(pk(~ltkD))
    ]

  /* Request a certificate from CAs */
rule DOMAIN_REQUEST_SIG_0:
      let request= <'RequestCert', $D, Did, ltpkD>
     in
     [
      !DomainInfo($D, Did, ltpkD)
     ]
  --[
     Is_Type('Domain', $D)
     ]->
    [
     Out_S($D, $CA, request)     // Obtain a signature from CA--Need k Sigs for a certificate.
    ]


  /* Domain requests signatures from at least k CAs
     This should be offline, or a secure out-of-band channel. Zhiguo
     */
rule CA_GENERATE_SIG_1:
  let request= <'RequestCert', $D, Did, ltpkD>
      Sig = sign( <'DomainCert', $D, Did, ltpkD>, ltkCA)
      Sig_full = <$D, Did, Sig, $CA>
  in
     [
      In_S($D, $CA, request),
      !Ltk($CA, ltkCA),			// Must have private key to sign the request.
      !Pk($D, ltpkD),
      !DomainInfo($D, Did, ltpkD)
     ]
  --[
     Is_Type('Domain', $D),
     Is_Type('CA', $CA),
     Uniq(<'ObtainSig', $D, Did, $CA>)		// A CA only provides a single signature
     ]->
    [
     Out_S($CA, $D, Sig_full)     // Obtain a signature from CA--Need k Sigs for a certificate.
    ]
  
  /* Collect sigs from CAs
     */
rule DOMAIN_RECIEVE_SIG_2:
   let
       Sig_full = <$D, Did, Sig, $CA>
   in

    [
     In_S($CA, $D, Sig_full),
     Sigs_List($D, Did, Sigs, CA_pks, nSigs),	// Update current Sigs_List, add a new sig into it. Zhiguo
     !DomainInfo($D, Did, ltpkD),
     !Pk($CA,ltpkCA),			// CA -- ltpkCA -- Sig -- CAs, Sigs---All bind together.
     !Pk($D, ltpkD)			// restriction fact for domain D, otherwise ltpkD may not be equal to pk(ltkD).
    ]
  --[
     Is_Type('Domain', $D),
     Is_Type('CA', $CA),
     Uniq( < 'Domain_CheckSig', $D, Did, $CA > ),		// A CA only provides a single signature, make it different from PHASE_1
//     NotIn( ltpkCA, CA_pks),		// 12.8 CA should be unique/different from each other, use public key. 
					// 12.9: not needed cos Uniq above.
     Eq(verify(Sig, <'DomainCert', $D, Did, ltpkD>, ltpkCA), true )
    ]->
    [Sigs_List($D, Did, Sigs + Sig_full, CA_pks + ltpkCA, nSigs + '1' )
     ]   // Added into Sigs_List after checking. Zhiguo
					// Sigs include Sig_full because Sig_full include $D and Did information
					// CA is a single symbol, i.e. 1 or 2 or 3 etc. 

/* If k sigs have been collected, domain owner submits it to BLMs for logging. 
  */
rule CREATE_CERT_REQUEST_3:
    let Cert_request = <$D, Did, Sigs, CA_pks>
    in
    [
    !PubParams(n, k, t),
    !DomainInfo($D, Did, ltpkD),
    Sigs_List($D, Did, Sigs, CA_pks, nSigs)
    ]
  --[
    Is_Type('Domain', $D),
    Eq(k+'nil', nSigs)		// k = '1'+ '3'. If k is in nSigs, then k Sigs are collected by domain owner.
    ]->
    [
    !Sigs_List_Final($D, Did, Sigs, CA_pks, nSigs),	// This list is consumed at Phase_5 by BLM
    Out( Cert_request )
    ]
/* Submit k signatures, and check each signature separately */ 
rule CHECK_CERT_REQUEST_4: 
   let 
//      Sig = sign( <'DomainCert', $D, ltpkD>, ltkCA)
      Sig_full = <$D, Did, Sig, $CA>
      Cert_request = <$D, Did, Sigs, CA_pks>
   in
    [
    In(Sig_full),
    In(Cert_request),
    !DomainInfo($D, Did, ltpkD),
    L_Sigs_Check_List($D, Did, Sigs_Checked),
    !Pk($CA, ltpkCA),
    !Pk($D, ltpkD)
    ]
  --[
    Is_Type('Domain', $D),
    Is_Type('CA', $CA),
    Uniq(<'BLM_CheckSig', $D, Did, $CA>),	// The CA's sig for is checked for only once.
    IsIn(Sig_full, Sigs),	// Received Sigs include a valid signature.
    Eq(verify(Sig, <'DomainCert', $D, Did, ltpkD>, ltpkCA), true )
    ]->
    [
    L_Sigs_Check_List($D, Did, Sigs_Checked + '1')
    ]

rule ISSUE_CERT_5:
    let
       record = sign(<$D, Did, Sigs, CA_pks, ltpkD>, ltkB)
    in
    [
    !Sigs_List_Final($D, Did,  Sigs, CA_pks, nSigs),
    !PubParams(n,k,t),
    L_Sigs_Check_List($D, Did, Sigs_Checked),
    !Ltk($B, ltkB),
    !Pk($D, ltpkD),
    L_Blog($B, blogid, blog) // Initially blog contains only 'nil'
    ]
  --[
    Eq(k+'nil', Sigs_Checked),		// All sigs have been checked.
    Is_Type('BLM', $B),
    Accept($D, Did, Sigs, CA_pks)
    ]->
    [
    Cert_Issued($D, Sigs, CA_pks),
    L_Blog($B, blogid, blog + record) // Recorded on the BLM's log, ie. the blockchain
    ]


/* Security property 1.
   Adversary need to compromise at least k CAs to get an invalid cert issued 
   on the blockchain log.
  */
#ifdef secure1
lemma invalid_cert_issued_more_than_k_compromised:
 "
 All D Did Sigs CA_pks #i1.

   /* If a domain has its cert successfully issued on the blockchain
   */

    (Accept(D, Did, Sigs, CA_pks) @ #i1

/* and less than k CAs have been compromised */
   &   not (Ex #i2 Compromised_CA_List.
                K_CAs_Compromised(Compromised_CA_List) @ #i2)

/* and BLM is not compromised */
   &   not (Ex #i3 B ltkB.
                Compromise_BLM(B,ltkB) @ #i3)
      )
      ==>
      ( /* the Domain must be a valid domain */
       (Ex #i4. Is_Type('Domain', D) @ #i4)
      )
 "
#endif

/* Security property 2.
   Adversary need to compromise at least t CAs to get an invalid cert revoked
   on the blockchain log.
  */
#ifdef secure2
lemma revoke_cert_issued_more_than_t_compromised:
 "
 All D Did Sigs CA_pks #i1.

   /* If a domain has its cert successfully issued on the blockchain
   */

    (Accept(D, Did, Sigs, CA_pks) @ #i1

/* and less than k CAs have been compromised */
   &   not (Ex #i2 Compromised_CA_List.
                K_CAs_Compromised(Compromised_CA_List) @ #i2)

/* and BLM is not compromised */
   &   not (Ex #i3 B ltkB.
                Compromise_BLM(B,ltkB) @ #i3)
      )
      ==>
      ( /* the Domain must be a valid domain */
       (Ex #i4. Is_Type('Domain', D) @ #i4)
      )
 "
#endif

 /* We can run protocol correctly without having any compromised party*/
#ifdef correct
lemma protocol_correctness:
 exists-trace
 " /* It is possible that */
   Ex D Did Sigs CAs #i1.

   /* The domain has its cert issued to the blockchain log
   */

   Accept(D, Did, Sigs, CAs) @ #i1

     /* without the adversary compromising any party. */
   &   not (Ex #i2 CA ltkCA.
                Compromise_CA(CA,ltkCA) @ #i2)

   &   not (Ex #i3 B ltkB.
                Compromise_BLM(B,ltkB) @ #i3)

"
#endif


end
