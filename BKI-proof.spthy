/* In this proof, strategies we adopt are:
   1. Log on blockchain is modelled as a list of records, and it is append-only;
   2. CAs' identities are modelled as '1', '1'+'1', '1'+'1'+'1', ...; There can be unlimited number of CAs.
   3. The model support any combination of k CAs to issue certs, any combination of t CAs to revoke certs.
   4. BLMs are modelled as single trusted BLM, as we assume the blockchain is securely maintained with consensus algorithms.
   5. BKI security can be proved under different n, k and t. E.g. n = '1'+'1'+'1', k = '1'+'1', t ='1'. 

To run the proof:
   tamarin-prover --prove BKI-proof.spthy -Dsecure1 -Dsecure2
*/


theory BKI_protocol_security

/* Author: Zhiguo Wan, wanzhiguo@sdu.edu.cn
   Shandong University
*/

/*
    =======Entity=======


    - Certificate authorities (CA) check the identity of domain
      owners, and create certificates for the domain owners'
      keys. However, in contrast with today's CAs, the ability of CAs
      in DTKI is limited since the issuance of a certificate from a CA
      is not enough to convince web browsers to accept the certificate
      (proof of presence in the relevant BLM is also needed).
    - Domain Servers
    - BLM: The BLMs in BKI is modeled as a single BLM.


    =======Adversary model=======

    We consider an adversary who can compromise the private key of all
    infrastructure servers in DTKI. In other words, the adversary can
    collude with all log servers and certificate authorities to launch
    attacks. In addition, we assume that each domain server can
    securely setup a master key with the corresponding BLM, and will
    be able to keep the master key private.

    =======Protocol=======
    See our paper on Securecomm'17.

    =======Notes=======

    Rule name: All capital, with '_' to separate words, e.g. RULE_NAME

    Actions: First letter is capital, with '_' to separate words,
    e.g. Action_Name

    State facts: Eg, 'StSecureCommA1' start with 'St', ends in role name
    and step in role that outputs it. By convention, the first argument
    is the thread identifier (tid), freshly generated in the first step
    of the role.

    Conclusion: First letter is capital, without '_',
    e.g. ConclusionName

    Lemma and restriction: lower case letter only, with '_' to separate
    words, e.g.lemma_name

*/

//theory BKI
begin

builtins: multiset

functions: adec/2, aenc/2, fst/1, h/1, pair/2, pk/1, sdec/2, senc/2,
  sign/2, snd/1, false/0, true/0, verify/3
equations:
    adec(aenc(x.1, pk(x.2)), x.2) = x.1,
    fst(<x.1, x.2>) = x.1,
    sdec(senc(x.1, x.2), x.2) = x.1,
    snd(<x.1, x.2>) = x.2,
    verify(sign(x.1, x.2), x.1, pk(x.2)) = true


restriction Unique: "All x #i #j. Uniq(x) @ i & Uniq(x) @ j ==> #i = #j"
restriction InEq:   "not (Ex x #i. InEq(x,x) @ i)"
restriction types_distinct:
  "(All t1 t2 x #i #j. (Is_Type(t1,x)@i & Is_Type(t2,x)@j) ==> (t1 = t2))"

restriction eq_check_succeed:
  "All x y #i. Eq(x,y) @ i ==> x = y"

//restriction neq_check_succeed:
//  "All x y #i. Neq(x,y) @ i ==> not (x = y)"

restriction notin_check_succeed:
  "All x l #i. NotIn(x,l) @ i ==> not (Ex rest. x+rest = l)"

restriction in_check_succeed:
  "All x l #i. IsIn(x,l) @ i ==> Ex rest. x+rest = l"

restriction subseteq_check_succeed:
  "All l m #i. SubsetEq(l,m) @ i ==> ( ( l = m ) | (Ex rest. l+rest = m) )"



/* Initialize the whole system */
rule INIT_SYSTEM_PARAMS:
   let 
        n = '1'+'1'+'1'+'1'+'1'		// n CAs in total. it can be set to any for test purpose.
        k = '1'+'1'+'1'		// k out of n CAs required to issue a cert.
        t = '1'+'1'				// t CAs to revoke a cert.
	Init = <'INITSYS', n, k, t>		// n,k,t can be decided by adversary.
   in
    [ In(Init) ]
    --[ SubsetEq(k, n),
        SubsetEq(t, k),
        InEq(n, 'nil'),
        InEq(k, 'nil'),
	Uniq('INITSYS')]->
    [!PubParams(n, k, t),
     L_Compromised_CAs('nil'),
      Out(<n, k, t>)]

/*Initialisation: Certificate log maintainer BLM. */

rule INIT_BLM:
    [ Fr(~ltkB)
//      Fr(~blogid)
      ]		
  --[ Is_Type('BLM', $B),
      Init_Blog($B, 'nil'),
      Uniq('INITBLM') 
    ]->
    [ !Ltk($B, ~ltkB),
      !Pk($B, pk(~ltkB)),
      StStateInitBLM($B, pk(~ltkB)),
      L_Blog($B, 'nil'), 		// the log maintained by the BLM 
      Out(pk(~ltkB))
    ]


  /* Initialisation: Certificate authorities*/

  rule INIT_CA:
  let q = < 'Init_CA', CAid, $CA>
  in
  [  In(q),
     Fr(~ltkCA),
     !PubParams(n, k, t)]
  --[
     Is_Type('CA', $CA),
     Uniq(<'CA', $CA>),		// Multiple CAs needed, each one is init only once
     Uniq(<'CA', CAid>),	
     IsIn(CAid, n+'1')		// $CA is in form of '1'+...+'1'
     ]->

  [ !Ltk($CA, ~ltkCA),
    !Pk($CA, pk(~ltkCA)),	// bind CA with its public key ltkCA. 
    !Pmap( CAid, $CA ),
    Out(pk(~ltkCA))
  ]


  /* Compromise a CA */

  rule COMPROMISE_CA:
   [ !Ltk($CA, ltkCA),
     L_Compromised_CAs(Compromised_CA_List)
    ]
  --[
     Is_Type('CA', $CA),
     Uniq(<'Compromise_CA', $CA>),
     Compromise_CA($CA,ltkCA)
     ]->

  [
   L_Compromised_CAs(Compromised_CA_List+'1'),
   Out(ltkCA)
  ]
  
  /* Compromise k CAs */
  rule COMPROMISE_k_CAs:
    [
   !PubParams(n,k,t),
   L_Compromised_CAs(Compromised_CA_List)
    ]
   --[
   Eq(k+'nil', Compromised_CA_List),			// k CAs are compromised
   K_CAs_Compromised(Compromised_CA_List)
    ]->[
   L_Compromised_CAs(Compromised_CA_List)
    ]
  
   /* Compromise t CAs */
   rule COMPROMISE_t_CAs:
     [
    !PubParams(n,k,t),
    L_Compromised_CAs(Compromised_CA_List)
     ]
    --[
    Eq(t+'nil', Compromised_CA_List),
    T_CAs_Compromised(Compromised_CA_List)
     ]->[
    L_Compromised_CAs(Compromised_CA_List)
     ]

  /* Compromise a BLM.
     BLM is modeled as a trusted pary, to represent the blockchain maintainer.
    */
  rule COMPROMISE_BLM:
          [ !Ltk($B, ltkB)
          ]
  --[
     Is_Type('BLM', $B),
     Compromise_BLM($B,ltkB)
     ]->[
   Out(ltkB),
   StCompromisedBLM($B,ltkB)
  ]

/*Initialisation: domain server Did*/

rule INIT_DOMAIN:
     [ Fr(~ltkD),
       Fr(~Did)
     ]
  --[ Is_Type('Domain', $D), 
      Uniq( < 'Init_Domain', $D > ) ]->	// A domain is initialze only once 
  [ !Ltk($D, ~ltkD),
    !Pk($D, pk(~ltkD)),			// public key of Domain, not persistent fact. 12.27--Zhiguo
    !DomainInfo($D, ~Did),
    F_Sigs_Check_List($D, ~Did, pk(~ltkD), 'nil'),		// To store sigs that have been verified. 
    F_Sigs_Revoke_Check_List($D, ~Did, pk(~ltkD), 'nil'),	// To store sigs that have been verified. 
    Out(~Did),
    Out(pk(~ltkD))
    ]


  /* Compromise a DOMAIN*/

  rule COMPROMISE_DOMAIN:
   [ !Ltk($D, ltkD)
    ]
  --[
     Is_Type('Domain', $D),
     Uniq(<'Compromise_Domain', $D>),
     Compromise_Domain($D,ltkD)
     ]->
  [
   Out(ltkD)
  ]

  /* Domain request a certificate from CAs */
rule DOMAIN_REQUEST_SIG_0:
      let request= <'RequestCert', $D, Did, ltpkD>
     in
     [
       !DomainInfo($D, Did),
       !Pk($D, ltpkD)
     ]
  --[
     Is_Type('Domain', $D)
     ]->
    [
     Out(<$D, $CA, request>)     
    ]


  /* Domain requests signatures from at least k CAs
     This should be offline, or a secure out-of-band channel. Zhiguo
     */
rule CA_GENERATE_SIG_1:
  let request= <'RequestCert', $D, Did, ltpkD>
      Sig = sign( <'DomainCert', $D, Did, ltpkD>, ltkCA)
  in
     [
      In(<$D, $CA, request>),
      !Ltk($CA, ltkCA),				// Must have private key to sign the request.
      !Pk($D, ltpkD),
      !DomainInfo($D, Did)
     ]
  --[
     Is_Type('Domain', $D),
     Is_Type('CA', $CA),
     Uniq(<'ObtainSig', $D, Did, $CA>)		// A CA only provides a single signature
     ]->
    [
     Out(<$CA, $D, Sig>)     		// Obtain a signature from CA--Need k Sigs for a certificate.
    ]
  

/* Submit k signatures, and check each signature separately */ 
rule BLM_CHECK_CERT_REQUEST_2: 
    [
    In(Sig),
    In(ltpkD),
    In(Did),
    F_Sigs_Check_List($D, Did, ltpkD, Sigs_Checked),
    !Pk($CA, ltpkCA)
    ]
  --[
    Is_Type('Domain', $D),
    Is_Type('CA', $CA),
    Uniq(<'BLM_CheckSig', $D, Did, $CA>),	// The CA's sig for is checked for only once.
    Eq(verify(Sig, <'DomainCert', $D, Did, ltpkD>, ltpkCA), true )
    ]->
    [
    F_Sigs_Check_List($D, Did, ltpkD, Sigs_Checked + '1')	// this fact is maintained by BLM
    ]

rule BLM_ISSUE_CERT_3: // Issued by BLM. ltpkD is obtained from In().  
		       // ltpkD inside Sigs should be the same as In(ltpkD).
    let
       record = < $D, Did, ltpkD, 'Valid' >
       record_revoke = < $D, Did, ltpkD, 'Revoked' >
       cert_domain = sign(record, ltkB)
    in
    [
    Fr(~CertID),		// 1.7
//    In(ltpkD),
    !Pk($D, ltpkD),
    !PubParams(n,k,t),
    F_Sigs_Check_List($D, Did, ltpkD, Sigs_Checked),
    !Ltk($B, ltkB),
    L_Blog($B, blog) // Initially blog contains only 'nil'
    ]
  --[
    Eq(k+'nil', Sigs_Checked),			// All sigs have been checked.
    Uniq(~CertID),
    Uniq(<'IssueCert',$D, Did, ltpkD>),
    Is_Type('BLM', $B),
    Is_Type('Domain', $D),
    NotIn(record, blog),
    NotIn(record_revoke, blog),			// 1.4 
//    Issue_Cert($B, blog, record),		
    Cert_Issued(~CertID, $D, Did, ltpkD)
    ]->
    [
    Out(cert_domain),
    Domain_Cert(~CertID, $D, Did, ltpkD, cert_domain),		// Domain's cert
    L_Blog($B, blog + record) 		// Recorded on the BLM's log, ie. the blockchain
    ]


   /* Request certificate revocation from CAs */
 rule DOMAIN_REQUEST_REVOKE_SIG_0:
       let request= <'RevokeCert', $D, Did, ltpkD>		// Different from cert request
      in
      [
       !Pk($D, ltpkD),
       !DomainInfo($D, Did)
      ]
   --[
      Is_Type('Domain', $D)
      ]->
     [
      Out(<$D, $CA, request>)     		// Obtain a signature from CA--
     ]
 
 
   /* Domain requests signatures from at least t CAs
      This should be offline, or a secure out-of-band channel. Zhiguo
      */
 rule CA_GENERATE_REVOKE_SIG_1:
   let request= <'RevokeCert', $D, Did, ltpkD>
       Sig = sign( <'RevokeCert', $D, Did, ltpkD>, ltkCA)
   in
      [
       In(<$D, $CA, request>),
       !Ltk($CA, ltkCA),			// Must have private key to sign the request.
       !Pk($D, ltpkD),
       !DomainInfo($D, Did)
      ]
   --[
      Is_Type('Domain', $D),
      Is_Type('CA', $CA),
      Uniq(<'ObtainRevokeSig', $D, Did, $CA>)		// A CA only provides a single signature
      ]->
     [
      Out(<$CA, $D, Sig>)     // Obtain a signature from CA--Need t Sigs to revoke a certificate.
     ]
   
/* Submit t signatures, and check each signature separately */
rule BLM_CHECK_CERT_REVOKE_REQUEST_2:
    [
    In(Sig),
    In(ltpkD),
    In(Did),
    F_Sigs_Revoke_Check_List($D, Did, ltpkD, Sigs_Checked),
    !Pk($CA, ltpkCA)
    ]
  --[
    Is_Type('Domain', $D),
    Is_Type('CA', $CA),
    Uniq(<'BLM_CheckRevokeSig', $D, Did, $CA>), // The CA's sig for is checked for only once.
    Eq(verify(Sig, <'RevokeCert', $D, Did, ltpkD>, ltpkCA), true )
    ]->
    [
    F_Sigs_Revoke_Check_List($D, Did, ltpkD, Sigs_Checked + '1')
    ]
 
 
 rule BLM_REVOKE_CERT_3:
     let
       record = < $D, Did, ltpkD, 'Valid' >
       record_revoke = < $D, Did, ltpkD, 'Revoked' >
       cert_domain = sign(record, ltkB)
       cert_domain_revoke = sign(record_revoke, ltkB)
     in
     [
     !PubParams(n,k,t),
     Fr(~RevokeID),
     Domain_Cert(CertID, $D, Did, ltpkD, cert_domain),
     F_Sigs_Revoke_Check_List($D, Did, ltpkD, Sigs_Checked),
     !Ltk($B, ltkB),
     L_Blog($B, blog) // Initially blog contains only 'nil'
     ]
   --[
     Eq(t+'nil', Sigs_Checked),		// All sigs have been checked.
     Is_Type('BLM', $B),
     Is_Type('Domain',$D),
     IsIn(record, blog),		// 1.6
     NotIn(record_revoke, blog),
//     Revoke_Cert($B, blog, record_revoke),	
     Uniq(<'RevokeCert',$D, Did, ltpkD>),
     Cert_Revoked(CertID, $D, Did, ltpkD)
     ]->
     [
     Domain_Cert_Revoke(~RevokeID, $D, Did, ltpkD, cert_domain_revoke),
     Out(cert_domain_revoke),
     L_Blog($B, blog + record_revoke) // Recorded on the BLM's log, ie. the blockchain
     ]

//  /* Start secure communication */
//
// rule SECURE_COMMUNICATION_USER_1:
//  let
//      record= < $D, Did, ltpkD, 'Valid' >
//  in
//    [
//     In(record),
//     Domain_Cert(CertID, cert_domain),
//     Fr(~n),
//     !Pk($B, ltpkB),
//     L_Blog($B, blog)
//     ]
//  --[
//     Is_Type('Domain', $D),
//     Is_Type('BLM', $B),
//     IsIn(record, blog),
//     Eq(verify(cert_domain, record, ltpkB), true),
//     Start_Role(<'SCU','U'>,<$D>)
//     ]->
//     [
//      Out(aenc{'1', ~n}ltpkD),
//      Domain_Cert(CertID, cert_domain),
//      StSend($D, Did, ~n, ltpkD),
//      L_Blog($B, blog)
//     ]
//
//  rule SECURE_COMMUNICATION_DOMAIN_1:
//  let 
//       m=aenc{'1', n}ltpkD
//  in
//    [
//     In(m),
//     !Ltk($D, ltkD)
//     ]
//  --[
//     Is_Type('Domain', $D),
//     Eq(fst(adec(m, ltkD)), '1'),
//     Start_Role(<'SCD','D'>,<$D>)
//     ]->
//     [
//      Out( h(snd(adec(m, ltkD))) )
//      ]
//
//rule SECURE_COMMUNICATION_USER_2:
//  [ StSend($D, Did, n, ltpkD),
//    In( h(n) )       // Receive hashed secret from network
//    ]
//  --[ Com_Done($D, Did, n, ltpkD) ]-> // State that the secret 'n' was sent to domain $D
//    [
//     StDone($D, Did, n, ltpkD)
//     ]



/* BLM checks that if a domain's cert is valid by checking the blockchain log.
*/

 rule VALID_CERT_CHECK:
      let
          record = < $D, Did, ltpkD, 'Valid' >
          record_revoke = < $D, Did, ltpkD, 'Revoked' >
      in
      [ 
         //In(<$D, Did, ltpkD>),
         !Pk($D, ltpkD),
         !DomainInfo($D, Did),
         !Pk($B, ltpkB),
         Domain_Cert(CertID, $D, Did, ltpkD, cert_domain),
         L_Blog($B, blog)
      ]
     --[
      Is_Type('BLM', $B),
      Is_Type('Domain', $D),
      IsIn(record, blog),		
      Eq(verify(cert_domain, record, ltpkB), true),
      NotIn(record_revoke, blog),
      Cert_Accepted(CertID, $D, Did, ltpkD),			// 1.7
      Accept_Cert($D, Did, ltpkD, CertID)
      ]->
      [ 
         Valid_Cert($D, Did, ltpkD),		// 1.6
         Domain_Cert(CertID, $D, Did, ltpkD, cert_domain),
         L_Blog($B, blog)
       ]
   
// rule INVALID_CERT_CHECK:
//      let
//          record_revoke = < $D, Did, ltpkD, 'Revoked' >
//      in
//      [ 
//         In(<$D, Did, ltpkD>),
//         !Pk($B, ltpkB),
//         Domain_Cert_Revoke(RevokeID, cert_domain_revoke),
//         L_Blog($B, blog)
//      ]
//     --[
//      Is_Type('BLM', $B),
//      Is_Type('Domain', $D),
//      IsIn(record_revoke, blog),		
//      Eq(verify(cert_domain_revoke, record_revoke, ltpkB), true),
//      Cert_Rejected(RevokeID)
//      ]->
//      [ 
//         Domain_Cert_Revoke(RevokeID, cert_domain_revoke),
//         L_Blog($B, blog)
//       ]

///* BLM checks that if a domain's cert is revoked by checking the blockchain log.
//*/
//rule INVALID_CERT_CHECK:
//    let
//        record_revoke= < $D, Did, ltpkD, 'Revoked' >
//    in
//    [ 
//       In(<Did, ltpkD>),
//       !Pk($B, ltpkB),
//       L_Blog($B, blog)
//    ]
//   --[
//    Is_Type('BLM', $B),
//    Is_Type('Domain', $D),
//    SubsetEq(record_revoke+'nil', blog),		
//    Not_Accept_Cert($D,Did, ltpkD)
//    ]->
//    [ 
//       L_Blog($B, blog)
//     ]
//  

// /* Update certificate by Domain itself.*/
// rule DOMAIN_UPDATE_CERT_0:
//      let 
// 	Sig = sign( <'UpdateCert', $D, pk(~newltkD), ltpkD>, ltkD)
//      in
//      [
//       !Ltk($D, ltkD),
//       !Pk($D, ltpkD),
//       Fr(~newltkD)
//      ]
//   --[
//      Is_Type('Domain', $D)
//      ]->
//     [
//      Out(<$D, pk(~newltkD), ltpkD, Sig>)
//     ]


  /* 
     */
//rule BLM_UPDATE_CERT_1:
//  let 
//       request = <$D, newltpkD, ltpkD, Sig>
//       record_update = < $D, Did, ltpkD, 'Valid' >
//  in
//     [
//      In(request),
//      !Ltk($B, ltkB),			// Must have private key to sign the request.
//      BLM_Log($D, Did, 'Valid')
//     ]
//  --[
//     Is_Type('Domain', $D),
//     Uniq(<'UpdateCert', $D, Did, ltpkD>),	// 
//     Eq(verify(Sig, <'UpdateCert', $D, newltpkD, ltpkD>, ltpkD), true ),
//     Is_Type('BLM', $B),
//     Accept_Update($D, Did, newltpkD, ltpkD)
//     ]->
//    [
//     BLM_Log($D, Did, 'Valid')
//    ]
  
/* Security property 1.
   Adversary need to compromise at least k CAs to get an invalid cert issued 
   on the blockchain log.
  */
#ifdef secure1
lemma valid_cert_issued_less_than_k_CAs_compromised:
 "
 All D Did ltpkD ltkD CertID #i1.// #i6.

   /* If a domain has its cert successfully issued on the blockchain
   */

    (  Accept_Cert(D, Did, ltpkD, CertID) @ #i1

/* and less than k CAs have been compromised */
   &   not (Ex #i2 Compromised_CA_List.
                K_CAs_Compromised(Compromised_CA_List) @ #i2)

/* and BLM is not compromised */
   &   not (Ex #i3 B ltkB.
                Compromise_BLM(B,ltkB) @ #i3)

   &   not (Ex #i4.
                Compromise_Domain(D,ltkD) @ #i4)

//   &   Accept_Cert(D, Did, ltpkD) @ #i6
   &  ltpkD = pk(ltkD)
      )
      ==>
      ( /* then the private key is not known by adversary */
       not (Ex #i5. KU(ltkD) @ #i5)
      )
 "
#endif

#ifdef secure2
/* Security property 2.
   Adversary need to compromise at least t CAs to get an invalid cert revoked
   on the blockchain log.
  */
lemma Issue_before_Check [reuse, use_induction]:
  "All D Did ltpkD CertID #j. Cert_Accepted(CertID, D, Did, ltpkD) @ j 
	==> (Ex #i. Cert_Issued(CertID, D, Did, ltpkD) @ i & i < j)"

lemma Check_before_Revoke [reuse, use_induction]:
  "All D Did ltpkD CertID #i #j. Cert_Revoked(CertID, D, Did, ltpkD) @ j & 
	Cert_Accepted(CertID, D, Did, ltpkD) @ i ==> #i < #j"

lemma valid_cert_revoke_less_than_t_CAs_compromised[use_induction]:
 "
 All D Did ltpkD CertID #i1.// #i4.

   /* If a domain's cert is successfully revoked on the blockchain
   */

    (Cert_Revoked(CertID, D, Did, ltpkD) @ #i1

/* and less than t CAs have been compromised */
   &   not (Ex #i2 Compromised_CA_List.
                T_CAs_Compromised(Compromised_CA_List) @ #i2)

/* and BLM is not compromised */
   &   not (Ex #i3 B ltkB.
                Compromise_BLM(B,ltkB) @ #i3)
      )
      ==>
      ( /* the public key cannot be accepted anymore */
      not (Ex #i4. (Cert_Accepted(CertID, D, Did, ltpkD) @ #i4   & i1 < i4))
      // i4 < i1
      )
 "
#endif

#ifdef secure3

/* Security property 3.
   Adversary need to compromise domain's private key to get an invalid cert updated
   on the blockchain log.
  */
lemma valid_cert_update_domain_not_compromised:
 "
 All D Did newltpkD newltkD ltpkD #i1.
 //All D Did newltpkD newltkD ltpkD ltkD #i1.

   /* If a domain has its cert successfully updated on the blockchain */

    (Accept_Update(D, Did, newltpkD, newltkD, ltpkD) @ #i1 

/* and Domain is not compromised */
   &   not (Ex #i2 D ltkD.
                Compromise_Domain(D,ltkD) @ #i2)
      )
      ==>
      ( /* the Domain must be a valid domain */
       not (Ex #i4. KU(newltkD) @ #i4)
      )
 "
#endif


 /* We can run protocol correctly without having any compromised party*/
#ifdef correct1
lemma protocol_correctness_issue:
 exists-trace
 " /* It is possible that */
   Ex D Did ltpkD #i1.

   /* The domain has its cert issued to the blockchain log
   */

   Accept_Cert(D, Did, ltpkD) @ #i1

     /* without the adversary compromising any party. */
   &   not (Ex #i2 CA ltkCA.
                Compromise_CA(CA,ltkCA) @ #i2)

   &   not (Ex #i3 B ltkB.
                Compromise_BLM(B,ltkB) @ #i3)

   &   not (Ex #i4.
                Compromise_Domain(D,ltkD) @ #i4)
"
#endif

#ifdef correct2
lemma protocol_correctness_revoke:
 exists-trace
 " /* It is possible that */
   Ex D Did ltkD ltpkD Sigs #i1.

   /* The domain has its cert issued to the blockchain log
   */

   Accept_Revoke(D, Did, ltpkD, Sigs ) @ #i1

     /* without the adversary compromising any party. */
   &   not (Ex #i2 CA ltkCA.
                Compromise_CA(CA,ltkCA) @ #i2)

   &   not (Ex #i3 B ltkB.
                Compromise_BLM(B,ltkB) @ #i3)

   &   not (Ex #i4.
                Compromise_Domain(D,ltkD) @ #i4)
   &   ltpkD = pk(ltkD)
"
#endif

#ifdef secure4
lemma message_secrecy_no_compromised_party:
 "
 All D Did m ltpkD #i1.

   /* If a user received a confirmation, i.e. hashed secret the user
   has sent, from the network */

   (Com_Done(D, Did, m, ltpkD) @ #i1

/* and no party has been compromised */
   &   not (Ex #i2 CA ltkCA.
                Compromise_CA(CA,ltkCA) @ #i2)

   &   not (Ex #i3 B ltkB.
                Compromise_BLM(B,ltkB) @ #i3)
   &   not (Ex #i5 D ltkD.
                Compromise_Domain(D,ltkD) @ #i5)

      )
      ==>
      ( /* then the adversary cannot know m */
       not (Ex #i4. K(m) @ #i4)
      )
 "
#endif

// lemma message_secrecy_compromise_all_domain_verified_master_cert:
//  "
//  All D Did m ltpkD #i1.
// 
//    /* If a user received a confirmation, i.e. hashed secret the user
//    has sent, from the network */
// 
//    (Com_Done(D, Did, m, ltpkD) @ #i1
// 
// /* and at an earlier time, the domain server has verified his master
// certificate */
// 
//      & Ex #i2.
//      VerifiedMasterCert(D, Did, rgx, ltpkD) @ #i2 &
//         #i2 < #i1
// /* and all parties can be compromised*/
//       )
//       ==>
//       ( /* then the adversary cannot know m */
//        not (Ex #i3. K(m) @ #i3)
//       )
//  "


end
