/* In this proof, strategies we adopt are:
   1. Secure channels are modelled between Domain and CAs with rules from tamarin manual.
   2. Log on blockchain is modelled as a list of records, and it is append-only;
   3. CAs' identities are modelled as '1', '1'+'1', '1'+'1'+'1', ...; There can be unlimited number of CAs.
   4. The model support any combination of k CAs to issue certs, any combination of t CAs to revoke certs.
   5. BLMs are modelled as single trusted BLM, as we assume the blockchain is securely maintained with consensus algorithms.

To run the proof:
   tamarin-prover --prove BKI-proof.spthy -Dsecure1 -Dsecure2
*/


theory BKI_protocol_security

/* Author: Zhiguo Wan, wanzhiguo@sdu.edu.cn
   Shandong University
*/

/*
    =======Entity=======


    - Certificate authorities (CA) check the identity of domain
      owners, and create certificates for the domain owners'
      keys. However, in contrast with today's CAs, the ability of CAs
      in DTKI is limited since the issuance of a certificate from a CA
      is not enough to convince web browsers to accept the certificate
      (proof of presence in the relevant BLM is also needed).
    - Domain Servers
    - BLM


    =======Adversary model=======

    We consider an adversary who can compromise the private key of all
    infrastructure servers in DTKI. In other words, the adversary can
    collude with all log servers and certificate authorities to launch
    attacks. In addition, we assume that each domain server can
    securely setup a master key with the corresponding BLM, and will
    be able to keep the master key private.

    =======Protocol=======
    See our paper on Securecomm'17.

    =======Notes=======

    Rule name: All capital, with '_' to separate words, e.g. RULE_NAME

    Actions: First letter is capital, with '_' to separate words,
    e.g. Action_Name

    State facts: Eg, 'StSecureCommA1' start with 'St', ends in role name
    and step in role that outputs it. By convention, the first argument
    is the thread identifier (tid), freshly generated in the first step
    of the role.

    Conclusion: First letter is capital, without '_',
    e.g. ConclusionName

    Lemma and restriction: lower case letter only, with '_' to separate
    words, e.g.lemma_name

*/

//theory BKI
begin

builtins: multiset

functions: adec/2, aenc/2, fst/1, h/1, pair/2, pk/1, sdec/2, senc/2,
  sign/2, snd/1, false/0, true/0, verify/3
equations:
    adec(aenc(x.1, pk(x.2)), x.2) = x.1,
    fst(<x.1, x.2>) = x.1,
    sdec(senc(x.1, x.2), x.2) = x.1,
    snd(<x.1, x.2>) = x.2,
    verify(sign(x.1, x.2), x.1, pk(x.2)) = true


restriction Unique: "All x #i #j. Uniq(x) @ i & Uniq(x) @ j ==> #i = #j"
restriction InEq:   "not (Ex x #i. InEq(x,x) @ i)"
restriction types_distinct:
  "(All t1 t2 x #i #j. (Is_Type(t1,x)@i & Is_Type(t2,x)@j) ==> (t1 = t2))"

restriction eq_check_succeed:
  "All x y #i. Eq(x,y) @ i ==> x = y"

restriction neq_check_succeed:
  "All x y #i. Neq(x,y) @ i ==> not (x = y)"

restriction notin_check_succeed:
  "All x l #i. NotIn(x,l) @ i ==> not (Ex rest. x+rest = l)"

restriction in_check_succeed:
  "All x l #i. IsIn(x,l) @ i ==> Ex rest. x+rest = l"

restriction subseteq_check_succeed:
  "All l m #i. SubsetEq(l,m) @ i ==> ( ( l = m ) | (Ex rest. l+rest = m) )"



/* Secure channel between Domain and CAs, it is authentic and confidential.
   1. When domain requests sigs from CAs;
   2. When domain requests revocation sigs from CAs.
*/
rule ChanOut_S:
        [ Out_S($A,$B,x) ]
      --[ ChanOut_S($A,$B,x) ]->
        [ !Sec($A,$B,x) ]

rule ChanIn_S:
        [ !Sec($A,$B,x) ]
      --[ ChanIn_S($A,$B,x) ]->
        [ In_S($A,$B,x) ]


/* Initialize the whole system */
rule INIT_SYSTEM_PARAMS:
   let 
//        n = '1'+'1'		// n CAs in total. it can be set to any for test purpose.
//        k = '1'+'1'			// k out of n CAs required to issue a cert.
//        t = '1'				// t CAs to revoke a cert.
	Init = <'INITSYS', n, k, t>		// n,k,t can be decided by adversary.
   in
    [ In(Init) ]
    --[ SubsetEq(k, n),
        SubsetEq(t, k),
        InEq(n, 'nil'),
        InEq(k, 'nil'),
	Uniq('INITSYS')]->
    [!PubParams(n, k, t),
     Compromised_CAs('nil'),
      Out(<n, k, t>)]

/*Initialisation: Certificate log maintainer BLM. */

rule INIT_BLM:
    [ Fr(~ltkB),
      Fr(~blogid)
      ]		
  --[ Is_Type('BLM', $B),
      Uniq('INITBLM') 
    ]->
    [ !Ltk($B, ~ltkB),
      !Pk($B, pk(~ltkB)),
//      StStateInitBLM($B, pk(~ltkB)),
      L_Blog($B, ~blogid, 'nil'), 		// the log maintained by the BLM 
      Out(pk(~ltkB))
    ]



/*Initialisation: Certificate log. */
//
//rule INIT_BLOG:
//     [
//      !Ltk($B, ltkB),
////      StStateInitBLM($B, pk(ltkB)),
//      Fr(~blogid)
//     ]
//   --[ Is_Type('BLM', $B),
//       Uniq('INITBLOG') 				// Log is initialized only once
//     ]->
//     [
//      L_Blog($B, ~blogid, 'nil') 		// the log maintained by the BLM 
//     ]
//

  /* Initialisation: Certificate authorities*/

  rule INIT_CA:
  let q = < 'Init_CA', CAid, $CA>
  in
  [  In(q),
     Fr(~ltkCA),
     !PubParams(n, k, t)]
  --[
     Is_Type('CA', $CA),
     Uniq(<'CA', $CA>),		// Multiple CAs needed, each one is init only once
     Uniq(<'CA', CAid>),	
     IsIn(CAid, n+'1')		// $CA is in form of '1'+...+'1'
     ]->

  [ !Ltk($CA, ~ltkCA),
    !Pk($CA, pk(~ltkCA)),	// bind CA with its public key ltkCA. 
    !Pmap( CAid, $CA ),
    Out(pk(~ltkCA))
  ]


  /* Compromise a CA */

  rule COMPROMISE_CA:
   [ !Ltk($CA, ltkCA),
     Compromised_CAs(Compromised_CA_List)
    ]
  --[
     Is_Type('CA', $CA),
     Uniq(<'Compromise_CA', $CA>),
     Compromise_CA($CA,ltkCA)
     ]->

  [
   Compromised_CAs(Compromised_CA_List+'1'),
   Out(ltkCA)
  ]
  
  /* Compromise k CAs */
  rule COMPROMISE_k_CAs:
    [
   !PubParams(n,k,t),
   Compromised_CAs(Compromised_CA_List)
    ]
   --[
//   Eq(k+'nil', Compromised_CA_List),			// k CAs are compromised
   SubsetEq(k+'nil', Compromised_CA_List),			// At least k CAs are compromised
   K_CAs_Compromised(Compromised_CA_List)
    ]->[
   Compromised_CAs(Compromised_CA_List)
    ]
  
  /* Compromise t CAs */
  rule COMPROMISE_t_CAs:
    [
   !PubParams(n,k,t),
   Compromised_CAs(Compromised_CA_List)
    ]
   --[
//   Eq(t+'nil', Compromised_CA_List),
   SubsetEq(t+'nil', Compromised_CA_List),
   T_CAs_Compromised(Compromised_CA_List)
    ]->[
   Compromised_CAs(Compromised_CA_List)
    ]
  /* Compromise a BLM.
     BLM is modeled as a trusted pary, to represent the blockchain maintainer.
    */

  rule COMPROMISE_BLM:
          [ !Ltk($B, ltkB)
          ]
  --[
     Is_Type('BLM', $B),
     Compromise_BLM($B,ltkB)
     ]->

  [
   Out(ltkB),
   StCompromisedBLM($B,ltkB)
  ]

/*Initialisation: domain server Did*/

rule INIT_DOMAIN:
     [ Fr(~ltkD),
       Fr(~Did)
     ]
  --[ Is_Type('Domain', $D), 
      Uniq( < 'Init_Domain', $D > ) ]->	// A domain is initialze only once 
  [ !LtkD($D, ~ltkD),
    !PkD($D, pk(~ltkD)),			// public key of Domain, not persistent fact. 12.27--Zhiguo
    !DomainInfo($D, ~Did),
    Sigs_List($D, ~Did, 'nil', 'nil'),	// The first list is sigs_list, the second is list of CA public keys, third is the counter //  the second is removed 12.30
    L_Sigs_Check_List($D, ~Did, 'nil'),		// To store sigs that have been verified. 
    Sigs_Revoke_List($D, ~Did, 'nil', 'nil'),	// The first list is sigs_list, the second is list of CA public keys, third is the counter
    L_Sigs_Revoke_Check_List($D, ~Did, 'nil'),		// To store sigs that have been verified. 
    F_BLM_Log($D, ~Did, 'nil'),
    Out(pk(~ltkD))
    ]


  /* Compromise a DOMAIN*/

  rule COMPROMISE_DOMAIN:
   [ !LtkD($D, ltkD)
    ]
  --[
     Is_Type('Domain', $D),
     Uniq(<'Compromise_Domain', $D>),
     Compromise_Domain($D,ltkD)
     ]->
  [
   Out(ltkD)
  ]

  /* Domain request a certificate from CAs */
rule DOMAIN_REQUEST_SIG_0:
      let request= <'RequestCert', $D, Did, ltpkD>
     in
     [
       !DomainInfo($D, Did),
       !PkD($D, ltpkD)
     ]
  --[
     Is_Type('Domain', $D)
     ]->
    [
//     PkD($D, ltpkD),
     Out_S($D, $CA, request)     
    ]


  /* Domain requests signatures from at least k CAs
     This should be offline, or a secure out-of-band channel. Zhiguo
     */
rule CA_GENERATE_SIG_1:
  let request= <'RequestCert', $D, Did, ltpkD>
      Sig = sign( <'DomainCert', $D, Did, ltpkD>, ltkCA)
  in
     [
      In_S($D, $CA, request),
      !Ltk($CA, ltkCA),				// Must have private key to sign the request.
      !PkD($D, ltpkD),
      !DomainInfo($D, Did)
     ]
  --[
     Is_Type('Domain', $D),
     Is_Type('CA', $CA),
     Uniq(<'ObtainSig', $D, Did, $CA>)		// A CA only provides a single signature
     ]->
    [
//     PkD($D, ltpkD),
     Out(Sig),
     Out_S($CA, $D, Sig)     		// Obtain a signature from CA--Need k Sigs for a certificate.
    ]
  
  /* Collect sigs from CAs
     */
rule DOMAIN_RECIEVE_SIG_2:
    [
     In_S($CA, $D, Sig),
     Sigs_List($D, Did, Sigs, nSigs),	// Update current Sigs_List, add a new sig into it. 
     !DomainInfo($D, Did),
     !Pk($CA,ltpkCA),				// CA -- ltpkCA
     !PkD($D, ltpkD)				// restriction fact for domain D
    ]
  --[
     Is_Type('Domain', $D),
     Is_Type('CA', $CA),
     Uniq( < 'Domain_CheckSig', $D, Did, $CA > ),		// A CA only provides a single signature, 
     Eq(verify(Sig, <'DomainCert', $D, Did, ltpkD>, ltpkCA), true )
    ]->
    [Sigs_List($D, Did, Sigs + Sig, nSigs + '1' )
//     PkD($D, ltpkD)				// restriction fact for domain D
     ]   // Added into Sigs_List after checking. Zhiguo

/* If k sigs have been collected, domain owner submits it to BLMs for logging. 
  */
rule CREATE_CERT_REQUEST_3:
    [
    !PubParams(n, k, t),
    !DomainInfo($D, Did),
    Sigs_List($D, Did, Sigs, nSigs)
    ]
  --[
    Is_Type('Domain', $D),
    Out_Domain_Sigs($D, Did, Sigs),
    Eq(k+'nil', nSigs)		// k = '1'+'1'+.... If k is in nSigs, then k Sigs are collected by domain owner
				// Note nSigs is initialized with 'nil', so we let k+'nil'
    ]->
    [
//    Out(Sigs),
    !Sigs_List_Final($D, Did, Sigs, nSigs)	// This list is used at Phase_5 by BLM
    ]
/* Submit k signatures, and check each signature separately */ 
rule CHECK_CERT_REQUEST_4: 
    [
    In(Sig),
    In(Sigs),
    !DomainInfo($D, Did),
    L_Sigs_Check_List($D, Did, Sigs_Checked),
    !Pk($CA, ltpkCA),
    !PkD($D, ltpkD)
    ]
  --[
    In_BLM_Sigs($D, Did, Sig, Sigs),			// to resolve partial deconstruction. 12.30
    Is_Type('Domain', $D),
    Is_Type('CA', $CA),
    Uniq(<'BLM_CheckSig', $D, Did, $CA>),	// The CA's sig for is checked for only once.
    IsIn(Sig, Sigs),			// Received Sigs include a valid signature.
    Eq(verify(Sig, <'DomainCert', $D, Did, ltpkD>, ltpkCA), true )
    ]->
    [
    //PkD($D, ltpkD),
    L_Sigs_Check_List($D, Did, Sigs_Checked + '1')
    ]

rule ISSUE_CERT_5:
    let
       record = < sign(<$D, Did, Sigs, ltpkD>, ltkB), $D, Did, 'Valid' >
       Sig_BLM = sign(<$D, Did, Sigs, ltpkD>, ltkB)
    in
    [
    !Sigs_List_Final($D, Did,  Sigs, nSigs),
    !PubParams(n,k,t),
    L_Sigs_Check_List($D, Did, Sigs_Checked),
    !Ltk($B, ltkB),
    !PkD($D, ltpkD),
    !LtkD($D, ltkD),
    F_BLM_Log($D, Did, 'nil'),
    L_Blog($B, blogid, blog) // Initially blog contains only 'nil'
    ]
  --[
    Eq(k+'nil', Sigs_Checked),			// All sigs have been checked.
    Add_Blog($B, blog, record),			// to resolve loop	12.31
    Uniq(<'IssueCert',$D, Did, ltpkD>),
    Is_Type('BLM', $B),
    Accept($D, Did, ltkD, Sigs)
    ]->
    [
    F_BLM_Log($D, Did, 'Valid'),
    //PkD($D, ltpkD),
    //LtkD($D, ltkD),
    L_Blog($B, blogid, blog + record) 		// Recorded on the BLM's log, ie. the blockchain
    ]


  /* Request certificate revocation from CAs */
rule DOMAIN_REQUEST_REVOKE_SIG_0:
      let request= <'RevokeCert', $D, Did, ltpkD>		// Different from cert request
     in
     [
      !PkD($D, ltpkD),
      !DomainInfo($D, Did)
     ]
  --[
     Is_Type('Domain', $D)
     ]->
    [
//     PkD($D, ltpkD),
     Out_S($D, $CA, request)     		// Obtain a signature from CA--
    ]


  /* Domain requests signatures from at least t CAs
     This should be offline, or a secure out-of-band channel. Zhiguo
     */
rule CA_GENERATE_REVOKE_SIG_1:
  let request= <'RevokeCert', $D, Did, ltpkD>
      Sig = sign( <'RevokeCert', $D, Did, ltpkD>, ltkCA)
  in
     [
      In_S($D, $CA, request),
      !Ltk($CA, ltkCA),			// Must have private key to sign the request.
      !PkD($D, ltpkD),
      !DomainInfo($D, Did)
     ]
  --[
     Is_Type('Domain', $D),
     Is_Type('CA', $CA),
     Uniq(<'ObtainRevokeSig', $D, Did, $CA>)		// A CA only provides a single signature
     ]->
    [
//     PkD($D, ltpkD),
     Out(Sig),
     Out_S($CA, $D, Sig)     // Obtain a signature from CA--Need t Sigs to revoke a certificate.
    ]
  
  /* Collect sigs from CAs
     */
rule DOMAIN_RECIEVE_REVOKE_SIG_2:
    [
     In_S($CA, $D, Sig),
     Sigs_Revoke_List($D, Did, Sigs, nSigs),	// Update current Sigs_List, add a new sig into it.
     !DomainInfo($D, Did),
     !Pk($CA,ltpkCA),			
     !PkD($D, ltpkD)			// restriction fact for domain D
    ]
  --[
     Is_Type('Domain', $D),
     Is_Type('CA', $CA),
     Uniq( < 'Domain_CheckRevokeSig', $D, Did, $CA > ),		// A CA only provides a single signature 
     Eq(verify(Sig, <'RevokeCert', $D, Did, ltpkD>, ltpkCA), true )
    ]->
    [
//    PkD($D, ltpkD),
      Sigs_Revoke_List($D, Did, Sigs + Sig, nSigs + '1' )
     ]   // Added into Sigs_List after checking. Zhiguo

/* If t sigs have been collected, domain owner submits it to BLMs for logging. 
  */
rule CREATE_CERT_REVOKE_REQUEST_3:
    [
    !PubParams(n, k, t),
    !DomainInfo($D, Did),
    Sigs_Revoke_List($D, Did, Sigs, nSigs)
    ]
  --[
    Is_Type('Domain', $D),
    Eq(t+'nil', nSigs)		// 
    ]->
    [
    !Sigs_Revoke_List_Final($D, Did, Sigs, nSigs)	// This list is used at Phase_5 by BLM
    ]
/* Submit t signatures, and check each signature separately */ 
rule CHECK_CERT_REVOKE_REQUEST_4: 
    [
    In(Sig),
    In(Sigs),
    !DomainInfo($D, Did),
    L_Sigs_Revoke_Check_List($D, Did, Sigs_Checked),
    !Pk($CA, ltpkCA),
    !PkD($D, ltpkD)
    ]
  --[
    Is_Type('Domain', $D),
    Is_Type('CA', $CA),
    Uniq(<'BLM_CheckRevokeSig', $D, Did, $CA>),	// The CA's sig for is checked for only once.
    IsIn(Sig, Sigs),	// Received Sigs include a valid signature.
    Eq(verify(Sig, <'RevokeCert', $D, Did, ltpkD>, ltpkCA), true )
    ]->
    [
    L_Sigs_Revoke_Check_List($D, Did, Sigs_Checked + '1')
//    PkD($D, ltpkD)
    ]

rule REVOKE_CERT_5:
    let
       record = < sign(<$D, Did, Sigs, ltpkD>, ltkB), $D, Did, 'Invalidated' >
    in
    [
    !Sigs_Revoke_List_Final($D, Did,  Sigs, nSigs),
    !PubParams(n,k,t),
    L_Sigs_Revoke_Check_List($D, Did, Sigs_Checked),
    !Ltk($B, ltkB),
    !PkD($D, ltpkD),
    F_BLM_Log($D, Did, 'Valid'),
    L_Blog($B, blogid, blog) // Initially blog contains only 'nil'
    ]
  --[
    Eq(t+'nil', Sigs_Checked),		// All sigs have been checked.
    Is_Type('BLM', $B),
    Uniq(<'RevokeCert',$D, Did, ltpkD>),
    Accept_Revoke($D, Did, ltpkD, Sigs )
    ]->
    [
    Cert_Revoked($D, Sigs ),
    F_BLM_Log($D, Did, 'Invalidated'),
//    PkD($D, ltpkD),
    L_Blog($B, blogid, blog + record) // Recorded on the BLM's log, ie. the blockchain
    ]


rule VALID_CERT_PRIVATE_KEY_TEST:
    [ 
     !PkD($D, ltpkD),
     F_BLM_Log($D, Did, status)
    ]
   --[
    Eq(status, 'Valid'),
    Accept_Cert($D,Did, ltpkD)
    ]->
    [ 
//     PkD($D, ltpkD),
     F_BLM_Log($D, Did, status)
     ]
   
///*
//rule INVALID_CERT_PRIVATE_KEY_TEST:
//    [ 
//     PkD($D, ltpkD),
//     F_BLM_Log($D, Did, status)
//    ]
//   --[
//    Eq(status, 'Invalidated'),
//    Not_Accept_Cert($D,Did, ltpkD)
//    ]->
//    [ 
//     PkD($D, ltpkD),
//     F_BLM_Log($D, Did, status)
//     ]
//*/
//   
//
///* Update certificate by Domain itself.*/
//rule DOMAIN_UPDATE_CERT_0:
//     let 
//	Sig = sign( <'UpdateCert', $D, pk(~newltkD), ltpkD>, ltkD)
//     in
//     [
//      LtkD($D, ltkD),
//      PkD($D, ltpkD),
//      Fr(~newltkD)
//     ]
//  --[
//     Is_Type('Domain', $D)
//     ]->
//    [
//     LtkD($D, ~newltkD),
//     PkD($D, pk(~newltkD)),
//     Out(<$D, pk(~newltkD), ltpkD, Sig>)
//    ]
//
//
//  /* 
//     */
//rule DOMAIN_UPDATE_CERT_1:
//  let 
//       request = <$D, newltpkD, ltpkD, Sig>
//  in
//     [
//      In(request),
//      !Ltk($B, ltkB),			// Must have private key to sign the request.
//      LtkD($D, newltkD),
//      F_BLM_Log($D, Did, 'Valid')
//     ]
//  --[
//     Is_Type('Domain', $D),
//     Uniq(<'UpdateCert', $D, Did, ltpkD>),	// 
//     Eq(verify(Sig, <'UpdateCert', $D, newltpkD, ltpkD>, ltpkD), true ),
//     Is_Type('BLM', $B),
//     Accept_Update($D, Did, newltpkD, newltkD, ltpkD)
//     ]->
//    [
//     LtkD($D, newltkD),
//     F_BLM_Log($D, Did, 'Valid')
//    ]
  
lemma Sigs_Types [sources]:
  " (All D Did Sig Sigs #i.
       In_BLM_Sigs(D, Did, Sig, Sigs) @ #i
      ==>
      ( (Ex #j. KU(Sigs)@ #j & #j < #i)
   	| (Ex #k. Out_Domain_Sigs(D, Did, Sigs)@k )
      )
    )
   "
/* Security property 1.
   Adversary need to compromise at least k CAs to get an invalid cert issued 
   on the blockchain log.
  */
#ifdef secure1
lemma valid_cert_issued_less_than_k_CAs_compromised:
 "
 All D Did ltkD Sigs #i1 #i6.

   /* If a domain has its cert successfully issued on the blockchain
   */

    (Accept(D, Did, ltkD, Sigs) @ #i1

/* and less than k CAs have been compromised */
   &   not (Ex #i2 Compromised_CA_List.
                K_CAs_Compromised(Compromised_CA_List) @ #i2)

/* and BLM is not compromised */
   &   not (Ex #i3 B ltkB.
                Compromise_BLM(B,ltkB) @ #i3)

   &   not (Ex #i4.
                Compromise_Domain(D,ltkD) @ #i4)

   &   Accept_Cert(D, Did, pk(ltkD)) @ #i6
      )
      ==>
      ( /* then the private key is not known by adversary */
       not (Ex #i5. KU(ltkD) @ #i5)
      )
 "
#endif

#ifdef secure2
/* Security property 2.
   Adversary need to compromise at least t CAs to get an invalid cert revoked
   on the blockchain log.
  */
lemma valid_cert_revoke_less_than_t_CAs_compromised:
 "
 All D Did ltpkD Sigs #i1 #i4.

   /* If a domain's cert is successfully revoked on the blockchain
   */

    (Accept_Revoke(D, Did, ltpkD, Sigs ) @ #i1

/* and less than t CAs have been compromised */
   &   not (Ex #i2 Compromised_CA_List.
                T_CAs_Compromised(Compromised_CA_List) @ #i2)

/* and BLM is not compromised */
   &   not (Ex #i3 B ltkB.
                Compromise_BLM(B,ltkB) @ #i3)
   &
       Accept_Cert(D, Did, ltpkD) @ #i4 
      )
      ==>
      ( /* the public key cannot be accepted anymore */
//      not (Ex #i4. (Accept_Cert(D, Did, ltpkD) @ #i4 & i1 < i4))
      i4 < i1
      )
 "
#endif

#ifdef secure3

/* Security property 3.
   Adversary need to compromise domain's private key to get an invalid cert updated
   on the blockchain log.
  */
lemma valid_cert_update_domain_not_compromised:
 "
 All D Did newltpkD newltkD ltpkD #i1.
 //All D Did newltpkD newltkD ltpkD ltkD #i1.

   /* If a domain has its cert successfully updated on the blockchain */

    (Accept_Update(D, Did, newltpkD, newltkD, ltpkD) @ #i1 

/* and Domain is not compromised */
   &   not (Ex #i2 D ltkD.
                Compromise_Domain(D,ltkD) @ #i2)
      )
      ==>
      ( /* the Domain must be a valid domain */
       not (Ex #i4. KU(newltkD) @ #i4)
      )
 "
#endif


 /* We can run protocol correctly without having any compromised party*/
#ifdef correct1
lemma protocol_correctness_issue:
 exists-trace
 " /* It is possible that */
   Ex D Did ltkD Sigs #i1.

   /* The domain has its cert issued to the blockchain log
   */

   Accept(D, Did, ltkD, Sigs ) @ #i1

     /* without the adversary compromising any party. */
   &   not (Ex #i2 CA ltkCA.
                Compromise_CA(CA,ltkCA) @ #i2)

   &   not (Ex #i3 B ltkB.
                Compromise_BLM(B,ltkB) @ #i3)

   &   not (Ex #i4.
                Compromise_Domain(D,ltkD) @ #i4)
"
#endif

#ifdef correct2
lemma protocol_correctness_revoke:
 exists-trace
 " /* It is possible that */
   Ex D Did ltkD Sigs #i1.

   /* The domain has its cert issued to the blockchain log
   */

   Accept_Revoke(D, Did, ltkD, Sigs ) @ #i1

     /* without the adversary compromising any party. */
   &   not (Ex #i2 CA ltkCA.
                Compromise_CA(CA,ltkCA) @ #i2)

   &   not (Ex #i3 B ltkB.
                Compromise_BLM(B,ltkB) @ #i3)

   &   not (Ex #i4.
                Compromise_Domain(D,ltkD) @ #i4)
"
#endif

end
